# 阻塞服务模型

需要有 **lombok** 以及 **logback**

```kotlin
// build.gradle.kts
plugins {
    java
}

group = "cc.sika"
version = "0.0.1-SNAPSHOT"

repositories {
    mavenCentral()
}
dependencies {
    implementation("ch.qos.logback:logback-classic:1.5.7")
	compileOnly ("org.projectlombok:lombok:1.18.34")
	annotationProcessor("org.projectlombok:lombok:1.18.34")
}
tasks.withType<JavaCompile> {
    options.encoding = "UTF-8"
}

tasks.withType<Test> {
    useJUnitPlatform()
}
tasks.withType<JavaExec> {
    systemProperty("file.encoding", "UTF-8")
}
```

服务器代码:

1. 使用ServerSocketChannel 的 open 方法获得对象
2. 使用 channel 对象的 bind(iNetSocketAddress) 方法将 channel 对象绑定到本机端口上
3. 使用 channel 的 accept 方法阻塞等待客户端连接
4. 阻塞完成后会得到一个 SocketChannel 对象
5. SocketChannel 可以获取到客户端发送的数据, 并将来自客户端的数据写入到本地服务器的缓冲区中进行相应操作

```java
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

/**
 * NIO 阻塞服务器示例
 */
@Slf4j
public class Server {
    public static void main(String[] args) throws IOException {

        List<SocketChannel> clients = new ArrayList<>();
        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {
            ByteBuffer buffer = ByteBuffer.allocate(16);

            ssc.bind(new InetSocketAddress(8088));

            while (true) {
                log.debug("connecting...");
                SocketChannel clientChannel = ssc.accept();
                log.debug("accepted! {}", clientChannel);
                clients.add(clientChannel);
                for (SocketChannel client : clients) {
                    log.debug("before read ~~ {}", client);
                    client.read(buffer);
                    buffer.flip();
                    log.info("client info is: {}", StandardCharsets.UTF_8.decode(buffer));
                    buffer.clear();
                    log.debug("after clear *** {}", client);
                }
            }
        }
    }
}
```

该代码会在accpet()方法时阻塞, 知道客户端连接成功

在接收到客户端消息前也会被 read() 方法阻塞, 知道接收到客户端数据时将数据输出, 清空缓冲区后重新回到 accept() 方法阻塞

只有在下一个客户端连接成功后才会继续第一个客户端再次发送的消息

如果要连接到该服务器, 可以使用下方的客户端代码

```java
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress("127.0.0.1", 8088));
socketChannel.write(StandardCharsets.UTF_8.encode("?"));
```

如果想要客户端能够同时接收并处理多个客户端的消息, 可以为每个客户端连接创建一个线程单独处理, 但是这样就违背了nio的设计初衷

